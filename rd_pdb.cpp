#include "rd_pdb.h"
#include "amino_acid.h"
#include "vector.h"
#include "rdfasta.h"
#include "calcsurf.h"
#include "dssp\\calcaccsurf.h"
Point::Point()
{
	x=0;y=0;z=0;
}
Atom::Atom()
{
	chain_seqm=0;
	c_resname='x';
	residule_chain_seqm=0;
	chain_identifier=-1;
	radium=0;
}
Residue::Residue()
{
	c_name='X';
	chain_seqm=0;
	num_atom=0;	
	alpha=phi=psi=omega=chi_1=chi_2=chi_3=chi_4=chi_5=-999.0;
	for(int i=0;i<NUM_ATOM_TYPE;i++)
		atom_index[i]=-1;
	num_contact=0;
}
Chain::Chain()
{
	chain_identifier='X';
	num_residue=0;
	num_atom=0;
}
Protein::Protein()
{
	num_chain=0;
}
void Residue::Clear()
{
	name.clear();
	c_name='X';
	chain_seqm=0;
	num_atom=0;
	m_atoms.clear();
	alpha=phi=psi=omega=chi_1=chi_2=chi_3=chi_4=chi_5=-999.0;
	for(int i=0;i<NUM_ATOM_TYPE;i++)
		atom_index[i]=-1;
	num_contact=0;
	saa=0;
	side_center.x=side_center.y=side_center.z=0;
	sidecenter_te13.x=sidecenter_te13.y=sidecenter_te13.z=0;;
	sidecenter_HRSC.x=sidecenter_HRSC.y=sidecenter_HRSC.z=0;
}
void Chain::Clear()
{
	chain_identifier=-1;
	m_residues.clear();
	num_residue=0;
	m_atoms.clear();
	num_atom=0;
	seq.clear();
	
}
void Protein::Clear()
{
	m_chains.clear();
	num_chain=0;
	PDB_id.clear();
	method.clear();
	resolution=0;
}
/*************************************************
 * read data from PDB files 
 * return true if sucess, otherwise return false
*************************************************/
bool  Protein::LoadFromPDB(string filename)
{
	ifstream filein;
	string line;
	bool model=false;//if multiple models,only deal with the first one
	vector<Atom> all_atom;
	if(filename.empty())
		return false;
	filein.open(filename.c_str(),ios::in);
	if(!filein.is_open())
		return false;

	Clear();
	while(!filein.eof())
	{
		getline(filein,line);		
		if(strcmp(line.substr(0,6).c_str(),"HEADER")==0) 
			process_header(line);
		else if(strcmp(line.substr(0,6).c_str(),"SOURCE")==0) 
			process_source(line);
		else if(strcmp(line.substr(0,6).c_str(),"EXPDTA")==0)
			process_expdta(line);
		else if(strcmp(line.substr(0,6).c_str(),"REMARK")==0)
			process_remark(line);
		else if(strcmp(line.substr(0,6).c_str(),"ATOM  ")==0) 
		{
			if(!model)
				process_atom(line,all_atom);
		}
		else if(strcmp(line.substr(0,6).c_str(),"ENDMDL")==0)
			model=true;
		else process_field(line);
	}

	AddAtom(all_atom);
	return true;
}
/*********************************************************
 * save information into files and return true if success
 ********************************************************/
bool Protein::SaveToFile(string filename)
{
	ofstream file;
	string line;
	Atom atom;
	int i,j;
	if(filename.empty())
		return false;
	file.open(filename.c_str(),ios::out);
	if(!file.is_open())
		return false;
	OutputPreField(file);
	int num_atom;
	for(i=0;i<num_chain;i++)
	{
		num_atom=m_chains[i].num_atom;
		for(j=0;j<num_atom;j++)
		{
			atom=m_chains[i].m_atoms[j];
			Atom2Line(atom,line);
			file<<line<<endl;
		}
		Atom2Ter(atom,line);
		file<<line<<endl;
	}
	OutputSucField(file);
	return true;
}

void Protein::process_header(const string& line)
{
	if((int)line.size()>=66)
		PDB_id=line.substr(62,4);
	process_field(line);
}
void Protein::process_expdta(const string& line)
{
	if(line.find(NMR)!=-1)
		method=NMR;
	else if(line.find(X_RAY)!=-1)
		method=X_RAY;
}
void Protein::process_source (const string& line)
{
	process_field(line);
}
void Protein::process_remark(const string& line)
{
	string id=line.substr(6,4);
	int r=atoi(id.c_str());
	double re;
	if(r==2)//´¦for resolution field
	{
		if(resolution<=0.0001)// haven't assigned value yet
		{
			id=line.substr(23,4);
			re=-1;
			re=atof(id.c_str());
			if(re<=0)
				resolution=0;
			else
				resolution=re;
		}
	}
	process_field(line);
}
void Protein::process_atom (const string& line, vector<Atom>& all_atom)
{
	int i,len;
	len=(int)line.size();
	Atom atom;
	string subline;
	if(len<7)
		return;
	subline=line.substr(6,5);
	atom.chain_seqm=atoi(subline.c_str());
	subline=line.substr(12,4);
	for(i=0;i<4;i++)
	{
		if(subline[i]!=' ')
			atom.name.push_back(subline[i]);
		Upper(atom.name);
	}
	// determine radium based on atom type and get the value from DSSP
	if(atom.name=="N")
		atom.radium=RN;
	else if(atom.name=="CA")
		atom.radium=RCA;
	else if(atom.name=="C")
		atom.radium=RC;
	else if(atom.name=="O")
		atom.radium=RO;
	else
		atom.radium=RSIDEATOM;

	subline=line.substr(17,3);
	atom.residule_name=subline;
	Upper(atom.residule_name);
	atom.c_resname=residulename321(subline.c_str());
	atom.chain_identifier=line.length()>=22?line[21]:' ';
	subline=line.substr(22,5);
	if(IsDigit(subline))
		atom.residule_chain_seqm=atoi(subline.c_str());
	else
		//atom.residule_chain_seqm=-1;//ignore the overlap 
		return;
	subline=line.substr(30,8);
	atom.pt.x=atof(subline.c_str());
	subline=line.substr(38,8);
	atom.pt.y=atof(subline.c_str());
	subline=line.substr(46,8);
	atom.pt.z=atof(subline.c_str());
	if(len>=60)
	{
		subline=line.substr(54,6);
		atom.occupancy=atof(subline.c_str());
	}
	if(len>=66)
	{
		subline=line.substr(60,6);
		atom.tempFactor=atof(subline.c_str());
	}
	if(len>=73)
		atom.segID=line.substr(72,4);
	if(len>=77)
		atom.element=line.substr(76,2);
	if(len>=79)
		atom.charge=line.substr(78,2);
	all_atom.push_back(atom);
}
/************************************************************
 * Add the atoms into protein by the order of reading sequence
 ************************************************************/
bool Protein::AddAtom(const vector<Atom>& all_atom)
{
	int len,i,index;
	Atom atom;
	Chain chain;
	Residue residue;

	chain.chain_identifier=NOCHAIN;
	residue.chain_seqm=NOSEQNUM;
	len=(int)all_atom.size();
	if(len<=0)//if no atom
		return true;
	for(i=0;i<len;i++)
	{
		atom=all_atom[i];
		if(atom.residule_chain_seqm!=residue.chain_seqm)
		{
			if(residue.chain_seqm!=NOSEQNUM)
			{
				chain.m_residues.push_back(residue);
				chain.num_residue++;			
				chain.seq.push_back(residue.c_name);
				residue.Clear();
			}
				residue.chain_seqm=atom.residule_chain_seqm;
				residue.name=atom.residule_name;
				residue.c_name=atom.c_resname;
				residue.num_atom=0;			
		}
		if(atom.chain_identifier!=chain.chain_identifier)
		{
			if(chain.chain_identifier!=NOCHAIN)
			{
				m_chains.push_back(chain);
				chain.Clear();			
				num_chain++;
			}
				chain.chain_identifier=atom.chain_identifier;
				chain.num_residue=0;	
				chain.num_atom=0;			
		}		
		atom.residule_seqm=chain.num_residue;
		chain.m_atoms.push_back(atom);
		residue.m_atoms.push_back(chain.num_atom);
		//residue.chain_seqm=atom.residule_chain_seqm;
		index=Atomname2ID(atom.name.c_str());
		if(index!=-1)
		{
			residue.atom_index[index]=chain.num_atom;
		}
		chain.num_atom++;		
		residue.num_atom++;
	}
	chain.m_residues.push_back(residue);
	chain.num_residue++;
	chain.seq.push_back(residue.c_name);
	m_chains.push_back(chain);
	num_chain++;
	return true;
}

void Protein::Atom2Line(const Atom& atom,string& line)
{
	char str[81];
	char name[5]="    ";
	if((int)atom.name.length()==4)//if the length of the name of atom is 4
	{
		for(int i=0;i<(int)atom.name.length();i++)
			name[i]=atom.name[i];
	}
	else//if the length is not 4,then the fisrt letter will be blank
	{
		for(int i=0;i<(int)atom.name.length()&&i<3;i++)
			name[i+1]=atom.name[i];
	}
	memset(str,' ',81);
	str[80]='\0';
	sprintf_s(str,"%s%5d %s %s %c%4d    %8.3f%8.3f%8.3f%6.2f%6.2f      %s%s%s","ATOM  ",atom.chain_seqm,name,atom.residule_name.c_str(),atom.chain_identifier,atom.residule_chain_seqm,atom.pt.x,atom.pt.y,atom.pt.z,atom.occupancy,atom.tempFactor,atom.segID.c_str(),atom.element.c_str(),atom.charge.c_str());
	line=str;
}
void Protein::Atom2Ter(const Atom& atom,string& line)
{
	char str[81];	
	memset(str,' ',81);
	str[80]='\0';
	sprintf_s(str,"%s%5d      %s %c%4d                                                      ","TER   ",atom.chain_seqm+1,atom.residule_name.c_str(),atom.chain_identifier,atom.residule_chain_seqm);
	line=str;
}
/********************************************
  * get all the contacts and return the total number
 ********************************************/
int Protein::ObtainContact(int chainnumber,vector<Contact>& all_contact)
{
	if(chainnumber<num_chain)
	{
		return m_chains[chainnumber].ObtainContact(all_contact);
	}
	else
		return 0;
}
/**************************************************
 * save contacts into files
 * return 0 if sucess, otherwise return -1
 ***********************************************/
int Protein::SaveContact(int chainnumber,const string& filename,const vector<Contact>& all_contact)
{
	if(chainnumber<num_chain)
		return m_chains[chainnumber].SaveContact(filename,all_contact);
	else
		return -1;
}
int Chain::ObtainContact(vector<Contact >& all_contact)
{
	int i,j,len;
	int id;
	double sider,d,t;
	bool findca,findcb;
	Point capt,cbpt,sidept;
	len=num_residue;
	//
	for(i=0;i<len;i++)
	{
		id=Rname2ID(m_residues[i].c_name);
		sider=AA_SideR[id];
		m_residues[i].side_radium=sider;
		findca=findcb=false;
		for(j=0;j<m_residues[i].num_atom;j++)
		{
			if(m_atoms[m_residues[i].m_atoms[j]].name=="CA")
			{
				capt=m_atoms[m_residues[i].m_atoms[j]].pt;
				findca=true;
			}
			if(m_atoms[m_residues[i].m_atoms[j]].name=="CB")
			{
				cbpt=m_atoms[m_residues[i].m_atoms[j]].pt;
				findcb=true;
			}
		}
		if(findca&&findcb)
		{
			d=Distance(capt,cbpt);
			t=sider/d;
			sidept.x=capt.x+(cbpt.x-capt.x)*t;
			sidept.y=capt.y+(cbpt.y-capt.y)*t;
			sidept.z=capt.z+(cbpt.z-capt.z)*t;
			m_residues[i].side_center=sidept;
		}
		else if(findca)
		{
			m_residues[i].side_center=capt;
		}				
	}
	Contact contact;
	double r1,r2;
	for(i=0;i<len;i++)
	{
		r1=m_residues[i].side_radium;
		for(j=i+1;j<len;j++)
		{
			r2=m_residues[j].side_radium;
			d=Distance(m_residues[i].side_center,m_residues[j].side_center);
			if(d<r1+r2+2.8)
			{
				contact.i1=i;
				contact.i2=j;
				all_contact.push_back(contact);
			}
		}
	}
	return (int)all_contact.size();
}
/*******************************************
 * ½«Ò»¸öÁ´µÄcontactÐÅÏ¢´æÈëÎÄ¼þÖÐ
 * ´æ´¢¸ñÊ½Îª£º
 * °±»ùËáÐòÁÐ
 * contact×ÜÊý
 * ËùÓÐµÄcontact
 * ³É¹¦Ê±·µ»Ø0£¬·ñÔò£¬·µ»Ø·Ç0£¬±íÊ¾
 * 1 ´ò²»¿ªÎÄ¼þ
 * 2 ÎÞ·¨Ð´ÈëÎÄ¼þ
 ******************************************/
int Chain::SaveContact(const string& filename,const vector<Contact>& all_contact)
{
	ofstream fileout;
	int len;
	if(filename.empty())
		return 1;
	fileout.open(filename.c_str(),ios::out);
	if(!fileout.is_open())
		return 1;
	fileout<<seq.c_str()<<endl;
	len=(int)all_contact.size();
	fileout<<len<<endl;
	for(int i=0;i<len;i++)
		fileout<<all_contact[i].i1<<' '<<all_contact[i].i2<<' ';	
	return 0;
}
int Protein::Get_Num_chain()
{
	return num_chain;
}
void Protein::Get_PDBID(string& id)
{
	id=PDB_id;
}
bool Protein::GetSeq(int chain,string& seq)
{
	if(chain>num_chain)
		return false;
	seq=m_chains[chain].seq;
	return true;
}
bool Chain::CalculateDihedral()
{
	int len,i,index,atom_index,rindex;
	Point p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11;
	len=(int)m_residues.size();
	for(i=0;i<len;i++)
	{
		//¼ÆËãalpha
		if((i>=1)&&(i<len-2))
		{
			index=Atomname2ID("CA");
			atom_index=m_residues[i-1].atom_index[index];
			if(atom_index==-1)
			{
				cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i-1<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
				return false;
			}
			p1=m_atoms[atom_index].pt;
			atom_index=m_residues[i].atom_index[index];
			if(atom_index==-1)
			{
				cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
				return false;
			}
			p2=m_atoms[atom_index].pt;
			atom_index=m_residues[i+1].atom_index[index];
			if(atom_index==-1)
			{
				cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i+1<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
				return false;
			}
			p3=m_atoms[atom_index].pt;
			atom_index=m_residues[i+2].atom_index[index];
			if(atom_index==-1)
			{
				cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i+2<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
				return false;
			}
			p4=m_atoms[atom_index].pt;
			m_residues[i].alpha=Dihedralangle(p1,p2,p3,p4);
		}		

		//¼ÆËãphi,psi,omega
		//if(i>0)
		{
			if(i>0)
			{
				index=Atomname2ID("C");
				atom_index=m_residues[i-1].atom_index[index];
				if(atom_index==-1)
				{
					cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i-1<<"ÖÐÕÒ²»µ½CÔ­×Ó"<<endl;
					return false;
				}
				p1=m_atoms[atom_index].pt;
			}
			index=Atomname2ID("N");
			atom_index=m_residues[i].atom_index[index];
			if(atom_index==-1)
			{
				cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½NÔ­×Ó"<<endl;
				return false;
			}
			p2=m_atoms[atom_index].pt;
			index=Atomname2ID("CA");
			atom_index=m_residues[i].atom_index[index];
			if(atom_index==-1)
			{
				cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
				return false;
			}
			p3=m_atoms[atom_index].pt;
			index=Atomname2ID("C");
			atom_index=m_residues[i].atom_index[index];
			if(atom_index==-1)
			{
				cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½CÔ­×Ó"<<endl;
				return false;
			}
			p4=m_atoms[atom_index].pt;
			if(i>0)
				m_residues[i].phi =Dihedralangle(p1,p2,p3,p4);
			if(i<len-1)
			{
				index=Atomname2ID("N");
				atom_index=m_residues[i+1].atom_index[index];
				if(atom_index==-1)
				{
					cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i+1<<"ÖÐÕÒ²»µ½CÔ­×Ó"<<endl;
					return false;
				}
				p5=m_atoms[atom_index].pt;
				m_residues[i].psi=Dihedralangle(p2,p3,p4,p5);
			
				index=Atomname2ID("CA");
				atom_index=m_residues[i+1].atom_index[index];
				if(atom_index==-1)
				{
					cout<<"¼ÆËãÁ½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i+1<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
					return false;
				}
				p6=m_atoms[atom_index].pt;
				m_residues[i].omega=Dihedralangle(p3,p4,p5,p6);
			}
			//¼ÆËã²àÁ´½Ç¶È
			rindex=Rname2ID20(m_residues[i].c_name);
			if(rindex!=-1)
			{
				if(haschi1[rindex])//¼ÆËãX1
				{
					index=Atomname2ID("CB");
					atom_index=m_residues[i].atom_index[index];
					if(atom_index==-1)
					{
						cout<<"¼ÆËã²àÁ´Á½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½CBÔ­×Ó"<<endl;
						return false;
					}
					p7=m_atoms[atom_index].pt;

					index=atomchi1[rindex];
					atom_index=m_residues[i].atom_index[index];
					if(atom_index==-1)
					{
						cout<<"¼ÆËã²àÁ´X1Á½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½Ö¸¶¨µÄÔ­×Ó"<<endl;
						return false;
					}
					p8=m_atoms[atom_index].pt;
					m_residues[i].chi_1=Dihedralangle(p2,p3,p7,p8);
				}
				if(haschi2[rindex])//¼ÆËãX2
				{
					index=atomchi2[rindex];
					atom_index=m_residues[i].atom_index[index];
					if(atom_index==-1)
					{
						cout<<"¼ÆËã²àÁ´X1Á½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½Ö¸¶¨µÄÔ­×Ó"<<endl;
						return false;
					}
					p9=m_atoms[atom_index].pt;
					m_residues[i].chi_2=Dihedralangle(p3,p7,p8,p9);
				}
				if(haschi3[rindex])//¼ÆËãX3
				{
					index=atomchi3[rindex];
					atom_index=m_residues[i].atom_index[index];
					if(atom_index==-1)
					{
						cout<<"¼ÆËã²àÁ´X1Á½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½Ö¸¶¨µÄÔ­×Ó"<<endl;
						return false;
					}
					p10=m_atoms[atom_index].pt;
					m_residues[i].chi_3=Dihedralangle(p7,p8,p9,p10);
				}
				if(haschi4[rindex])//¼ÆËãX4
				{
					index=atomchi4[rindex];
					atom_index=m_residues[i].atom_index[index];
					if(atom_index==-1)
					{
						cout<<"¼ÆËã²àÁ´X1Á½Ãæ½ÇÊ±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½Ö¸¶¨µÄÔ­×Ó"<<endl;
						return false;
					}
					p11=m_atoms[atom_index].pt;
					m_residues[i].chi_4=Dihedralangle(p8,p9,p10,p11);
				}
			}
			
		}
		
	
	}
		return true;
}
bool Chain::WriteDihedral(const string filename)
{
	ofstream file(filename.c_str());
	if(!file.is_open())
		return false;
	int i,len;
	len=(int)m_residues.size();
	file<<"Á½Ãæ½Ç"<<endl;
	
	file<<"ÐòºÅ"<<'\t'<<"°±»ùËáÃû³Æ"<<'\t'<<"alpha"<<'\t'<<"phi"<<'\t'<<"psi\t"<<"omega\t"<<endl;
	for(i=0;i<len;i++)
	{
		file<<i<<'\t'<<m_residues[i].name<<'\t';
		file.precision(7);
		file<<m_residues[i].alpha<<'\t';
		file.precision(7);
		file<<m_residues[i].phi<<'\t';
		file.precision(7);
		file<<m_residues[i].psi<<'\t';
		file.precision(7);
		file<<m_residues[i].omega <<'\t';

		file<<endl;
	}
	return true;
}
/*********************************************************
 * ¸ù¾ÝÁ½Ãæ½Ç½øÐÐµ°°×ÖÊÈýÎ¬½á¹¹µÄ×ø±êÖØ½¨
 * ¾ßÌå·½·¨Çë²Î¿¼ÉúÎïÐÅÏ¢Ñ§Ñ§Ï°±Ê¼Ç2ÖÐµÄ×¨Ìâ8.8
 * ÐèÒªËµÃ÷µÄÊÇ,ÓÉÓÚÔÚÖØ½¨¹ý³ÌÖÐÊ¹ÓÃµÄ¼ü³¤¼ü½Ç
 * ¶¼ÊÇÔÚÄÜÁ¿×îµÍÊ±µÄ¾­ÑéÖµ£¬ÖØ½¨ºóµÄ×ø±ê²¢²»ÄÜ
 * ºÍÔ­À´×ø±êÍêÈ«ÖØºÏ
 * Ð£×¼µÄ¼ü³¤¼ü½ÇÈ¡×ÔAMBERÊÆÄÜº¯Êý£¬¼ûµ°°×ÖÊ½á¹¹
 * ×¼ÔòÒ»ÎÄ¡£
 * ÁíÍâ£¬¼´Ê¹ÊÇ°´ÕÕPDBÎÄ¼þÖÐ¸ø³öµÄ×ø±êÀ´¼ÆËã¼ü³¤
 * ºÍ¼ü½Ç£¬Ò²²»ÄÜºÍ±ê×¼×´Ì¬ÏÂµÄÖµ£¬ÍêÈ«Ò»Ñù
 * Ä¿Ç°½öÍê³É¶ÔÖ÷Á´Ô­×Ó(³ýÁËOÔ­×Ó)½øÐÐÖØ½¨
 * ÊµÑé½á¹ûÏÔÊ¾£ºÕâÖÖÖØ½¨·½·¨ºÍÊµÑéÖµ»ù±¾ÎÇºÏ
 * µ«ÊÇ»á³öÏÖÀÛ¼ÆÎó²î£¬ºóÃæµÄÔ­×ÓµÄ×ø±êÆ«²î½Ï´ó
 * ´óÔ¼Îª2°£
 *********************************************************/
bool Chain::Rebuildxyz_Dihedral()
{
	int len=(int)m_residues.size();
	int i;
	int index,atom_index;
	Point qN,qCA,qC;//Ç°Ãæ°±»ùËáµÄCa,C,NÔ­×Ó×ø±ê
	Point N,CA,C,O;//µ±Ç°°±»ùËáµÄN,Ca,C,OÔ­×Ó×ø±ê
	double theta,tao,bond_len;

	//¶ÔµÚÒ»¸ö°±»ùËáµÄÏàÓ¦Ô­×Ó¸³Öµ£¬ÕâÀï¿½±´Ô­ÓÐ×ø±ê

	for(i=1;i<len-1;i++)//ÒÀ´Î¶ÔËæºóµÄ°±»ùËáÖÐµÄÔ­×Ó½øÐÐ×ø±êÖØ½¨
	{
		//¼ÆËãµ±Ç°°±»ùËáµÄN
		index=Atomname2ID("N");
		atom_index=m_residues[i-1].atom_index[index];
		if(atom_index==-1)
		{
			cout<<"×ø±êÖØ½¨Ê±Ê±³ö´í£ºÔÚ°±»ùËá"<<i-1<<"ÖÐÕÒ²»µ½NÔ­×Ó"<<endl;
			return false;
		}
		qN=m_atoms[atom_index].pt;

		index=Atomname2ID("CA");
		atom_index=m_residues[i-1].atom_index[index];
		if(atom_index==-1)
		{
			cout<<"×ø±êÖØ½¨Ê±Ê±³ö´í£ºÔÚ°±»ùËá"<<i-1<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
			return false;
		}
		qCA=m_atoms[atom_index].pt;
		index=Atomname2ID("C");
		atom_index=m_residues[i-1].atom_index[index];
		if(atom_index==-1)
		{
			cout<<"×ø±êÖØ½¨Ê±Ê±³ö´í£ºÔÚ°±»ùËá"<<i-1<<"ÖÐÕÒ²»µ½CÔ­×Ó"<<endl;
			return false;
		}
		qC=m_atoms[atom_index].pt;
		
		//¼ÆËãµ±Ç°µÄNÔ­×Ó×ø±ê
		theta=m_residues[i-1].psi;//Á½Ãæ½Ç
		tao=116.6;//Ca-C-N¼ü½Ç
		bond_len=1.335;//C-N¼ü³¤
		N=LastXYZ(qN,qCA,qC,theta,tao,bond_len);
		index=Atomname2ID("N");
		atom_index=m_residues[i].atom_index[index];
		if(atom_index==-1)
		{
			cout<<"×ø±êÖØ½¨Ê±Ê±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½NÔ­×Ó"<<endl;
			return false;
		}
		m_atoms[atom_index].pt=N;

		//¶Ôµ±Ç°µÄCAÔ­×Ó½øÐÐ×ø±êÖØ½¨
		theta=m_residues[i-1].omega;
		tao=121.9;//C-N-CA¼ü½Ç
		bond_len=1.449;//N-CA¼ü³¤
		CA=LastXYZ(qCA,qC,N,theta,tao,bond_len);
		index=Atomname2ID("CA");
		atom_index=m_residues[i].atom_index[index];
		if(atom_index==-1)
		{
			cout<<"×ø±êÖØ½¨Ê±Ê±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
			return false;
		}
		m_atoms[atom_index].pt=CA;

		//¶Ôµ±Ç°µÄCÔ­×Ó½øÐÐ×ø±êÖØ½¨
		theta=m_residues[i].phi;
		tao=110.3;//N-CA-C¼ü½Ç
		bond_len=1.522;//CA-C¼ü³¤
		C=LastXYZ(qC,N,CA,theta,tao,bond_len);
		index=Atomname2ID("C");
		atom_index=m_residues[i].atom_index[index];
		if(atom_index==-1)
		{
			cout<<"×ø±êÖØ½¨Ê±Ê±³ö´í£ºÔÚ°±»ùËá"<<i<<"ÖÐÕÒ²»µ½CÔ­×Ó"<<endl;
			return false;
		}
		m_atoms[atom_index].pt=C;


	}
	return true;
}
bool Protein::WriteSeqFasta(string filename)
{
	if(filename.empty())
		return false;
	ofstream file;
	file.open(filename.c_str());
	if(!file.is_open())
		return false;
	string header,header1;
	header1=this->PDB_id;
	if(header1.empty())
		header1=filename;
	int i;
	for(i=0;i<(int)m_chains.size();i++)
	{
		header=header1+m_chains[i].chain_identifier;
		if(!WriteFastaSeq(file,m_chains[i].seq,header))
			return false;
	}
	return true;
}
bool Protein::WriteSeqFasta_total(string filename)
{
	if(filename.empty())
		return false;
	string seq;
	ofstream file;
	file.open(filename.c_str());
	if(!file.is_open())
		return false;
	string header,header1;
	header1=this->PDB_id;
	if(header1.empty())
		header1=filename;
	int i;
	for(i=0;i<(int)m_chains.size();i++)
	{		
		seq+=m_chains[i].seq;			
	}
	if(!WriteFastaSeq(file,seq,header1))
		return false;
	return true;
}
//´¦ÀíÁãÉ¢µÄ×Ö¶Î£¬½ö½ö¼ÇÂ¼Êý¾Ý
void Protein::process_field(const string& line)
{
	string subline=line.substr(0,6);
	if(subline=="ANISOU")
		anisou.push_back(line);
	else if(subline=="AUTHOR")
		author.push_back(line);
	else if(subline=="CISPEP")
		cispep.push_back(line);
	else if(subline=="COMPND")
		compnd.push_back(line);
	else if(subline=="CONECT")
		conect.push_back(line);
	else if(subline=="CRYST1")
		cryst1.push_back(line);
	else if(subline=="DBREF ")
		dbref.push_back(line);
	else if(subline=="EXPDTA")
		expdta.push_back(line);
	else if(subline=="FORMUL")
		formul.push_back(line);
	else if(subline=="FTNOTE")
		ftnote.push_back(line);
	else if(subline=="HEADER")
		header.push_back(line);
	else if(subline=="HELIX ")
		helix.push_back(line);
	else if(subline=="HET   ")
		het.push_back(line);
	else if(subline=="HETATM")
		hetatm.push_back(line);
	else if(subline=="HETNAM")
		hetnam.push_back(line);
	else if(subline=="HETSYN")
		hetsyn.push_back(line);
	else if(subline=="HYDBND")
		hydbnd.push_back(line);
	else if(subline=="JNRL  ")
		jnrl.push_back(line);
	else if(subline=="JRNL  ")
		jrnl.push_back(line);
	else if(subline=="KEYWDS")
		keywds.push_back(line);
	else if(subline=="LINK  ")
		link.push_back(line);
	else if(subline=="MASTER")
		master.push_back(line);
	else if(subline=="MODRES")
		modres.push_back(line);
	else if(subline=="MTRIX1")
		mtrix1.push_back(line);
	else if(subline=="MTRIX2")
		mtrix2.push_back(line);
	else if(subline=="MTRIX3")
		mtrix3.push_back(line);
	else if(subline=="ORIGX1")
		origx1.push_back(line);
	else if(subline=="ORIGX2")
		origx2.push_back(line);
	else if(subline=="ORIGX3")
		origx3.push_back(line);
	else if(subline=="REMARK")
		remark.push_back(line);
	else if(subline=="REVDAT")
		revdat.push_back(line);
	else if(subline=="SCALE1")
		scale1.push_back(line);
	else if(subline=="SCALE2")
		scale2.push_back(line);
	else if(subline=="SCALE3")
		scale3.push_back(line);
	else if(subline=="SEQADV")
		seqadv.push_back(line);
	else if(subline=="SEQRES")
		seqres.push_back(line);
	else if(subline=="SHEET ")
		sheet.push_back(line);
	else if(subline=="SITE  ")
		site.push_back(line);
	else if(subline=="SLTBRG")
		sltbrg.push_back(line);
	else if(subline=="SOURCE")
		source.push_back(line);
	else if(subline=="SPRSDE")
		sprsde.push_back(line);
	else if(subline=="SSBOND")
		ssbond.push_back(line);
	else if(subline=="TITLE ")
		title.push_back(line);
	else if(subline=="TURN  ")
		turn.push_back(line);
	else if(subline=="TVECT")
		tvect.push_back(line);
	else if(subline=="END   ")
		end.push_back(line);
}
void Protein::OutputPreField(ofstream& file)
{
	int i;
	if(!header.empty())
	{
		for(i=0;i<(int)header.size();i++)
			file<<header[i]<<endl;
	}
	if(!title.empty())
	{
		for(i=0;i<(int)title.size();i++)
			file<<title[i]<<endl;
	}
	if(!compnd.empty())
	{
		for(i=0;i<(int)compnd.size();i++)
			file<<compnd[i]<<endl;
	}
	if(!source.empty())
	{
		for(i=0;i<(int)source.size();i++)
			file<<source[i]<<endl;
	}
	if(!keywds.empty())
	{
		for(i=0;i<(int)keywds.size();i++)
			file<<keywds[i]<<endl;
	}
	if(!expdta.empty())
	{
		for(i=0;i<(int)expdta.size();i++)
			file<<expdta[i]<<endl;
	}
	if(!author.empty())
	{
		for(i=0;i<(int)author.size();i++)
			file<<author[i]<<endl;
	}
	if(!revdat.empty())
	{
		for(i=0;i<(int)revdat.size();i++)
			file<<revdat[i]<<endl;
	}
	if(!sprsde.empty())
	{
		for(i=0;i<(int)sprsde.size();i++)
			file<<sprsde[i]<<endl;
	}
	if(!jnrl.empty())
	{
		for(i=0;i<(int)jnrl.size();i++)
			file<<jnrl[i]<<endl;
	}
	if(!jrnl.empty())
	{
		for(i=0;i<(int)jrnl.size();i++)
			file<<jrnl[i]<<endl;
	}
	if(!remark.empty())
	{
		for(i=0;i<(int)remark.size();i++)
			file<<remark[i]<<endl;
	}
	if(!dbref.empty())
	{
		for(i=0;i<(int)dbref.size();i++)
			file<<dbref[i]<<endl;
	}
	if(!seqadv.empty())
	{
		for(i=0;i<(int)seqadv.size();i++)
			file<<seqadv[i]<<endl;
	}
	if(!seqres.empty())
	{
		for(i=0;i<(int)seqres.size();i++)
			file<<seqres[i]<<endl;
	}
	if(!modres.empty())
	{
		for(i=0;i<(int)modres.size();i++)
			file<<modres[i]<<endl;
	}
	if(!ftnote.empty())
	{
		for(i=0;i<(int)ftnote.size();i++)
			file<<ftnote[i]<<endl;
	}
	if(!het.empty())
	{
		for(i=0;i<(int)het.size();i++)
			file<<het[i]<<endl;
	}
	if(!hetnam.empty())
	{
		for(i=0;i<(int)hetnam.size();i++)
			file<<hetnam[i]<<endl;
	}
	if(!hetsyn.empty())
	{
		for(i=0;i<(int)hetsyn.size();i++)
			file<<hetsyn[i]<<endl;
	}
	if(!formul.empty())
	{
		for(i=0;i<(int)formul.size();i++)
			file<<formul[i]<<endl;
	}
	if(!helix.empty())
	{
		for(i=0;i<(int)helix.size();i++)
			file<<helix[i]<<endl;
	}
	if(!sheet.empty())
	{
		for(i=0;i<(int)sheet.size();i++)
			file<<sheet[i]<<endl;
	}
	if(!turn.empty())
	{
		for(i=0;i<(int)turn.size();i++)
			file<<turn[i]<<endl;
	}
	if(!ssbond.empty())
	{
		for(i=0;i<(int)ssbond.size();i++)
			file<<ssbond[i]<<endl;
	}
	if(!hydbnd.empty())
	{
		for(i=0;i<(int)hydbnd.size();i++)
			file<<hydbnd[i]<<endl;
	}
	if(!sltbrg.empty())
		{
		for(i=0;i<(int)sltbrg.size();i++)
			file<<sltbrg[i]<<endl;
	}	
	if(!link.empty())
	{
		for(i=0;i<(int)link.size();i++)
			file<<link[i]<<endl;
	}
	if(!cispep.empty())
	{
		for(i=0;i<(int)cispep.size();i++)
			file<<cispep[i]<<endl;
	}
	if(!site.empty())
	{
		for(i=0;i<(int)site.size();i++)
			file<<site[i]<<endl;
	}
	if(!cryst1.empty())
	{
		for(i=0;i<(int)cryst1.size();i++)
			file<<cryst1[i]<<endl;
	}
	if(!origx1.empty())
	{
		for(i=0;i<(int)origx1.size();i++)
			file<<origx1[i]<<endl;
	}
	if(!origx2.empty())
	{
		for(i=0;i<(int)origx2.size();i++)
			file<<origx2[i]<<endl;
	}
	if(!origx3.empty())
	{
		for(i=0;i<(int)origx3.size();i++)
			file<<origx3[i]<<endl;
	}
	if(!scale1.empty())
	{
		for(i=0;i<(int)scale1.size();i++)
			file<<scale1[i]<<endl;
	}
	if(!scale2.empty())
	{
		for(i=0;i<(int)scale2.size();i++)
			file<<scale2[i]<<endl;
	}
	if(!scale3.empty())
	{
		for(i=0;i<(int)scale3.size();i++)
			file<<scale3[i]<<endl;
	}
	if(!mtrix1.empty())
	{
		for(i=0;i<(int)mtrix1.size();i++)
			file<<mtrix1[i]<<endl;
	}
	if(!mtrix2.empty())
	{
		for(i=0;i<(int)mtrix2.size();i++)
			file<<mtrix2[i]<<endl;
	}
	if(!mtrix3.empty())
	{
		for(i=0;i<(int)mtrix3.size();i++)
			file<<mtrix3[i]<<endl;
	}
	if(!tvect.empty())
	{
		for(i=0;i<(int)tvect.size();i++)
			file<<tvect[i]<<endl;
	}
}
//anisouÔÝÊ±Î´´¦Àí
void Protein::OutputSucField(ofstream& file)
{
	int i;
	if(!hetatm.empty())
	{
			for(i=0;i<(int)hetatm.size();i++)
				file<<hetatm[i]<<endl;
	}
	if(!conect.empty())
	{
			for(i=0;i<(int)conect.size();i++)
				file<<conect[i]<<endl;
	}
	if(!master.empty())
	{
			for(i=0;i<(int)master.size();i++)
				file<<master[i]<<endl;
	}
	if(!end.empty())
	{
		for(i=0;i<(int)end.size();i++)
				file<<end[i]<<endl;
	}
	else
		file<<"END                                                                             ";

			
}
/**************************************************
 * ½«Ã¿¸öÁ´µÄÐÅÏ¢·Ö±ð´æÈëÎÄ¼þÖÐ
 * Èç¹ûfilenameÎªÄ¬ÈÏÖµ£¬ÔòÎÄ¼þÃûÎªpdb±êÊ¶+Á´±êÊ¶.ent
 * Èç¹ûÎÄ¼þÃû²»ÎªÄ¬ÈÏÖµ£¬Ôò½«Á´±êÊ¶²åÈëµ½×îºóÒ»¸ö.Ö®Ç°
 * µ±µ±Ç°µÄµ°°×ÖÊÖÐ½öÓÐÒ»¸öÁ´£¬ÔòÎÄ¼þÃûÖÐ²»¼ÓÁ´±êÊ¶
 * Èç¹ûÁ´±êÊ¶Îª¿Õ¸ñ£¬ÔòÔÚÐèÒª±íÊ¾Ê±£¬ÓÃA±íÊ¾
 ***************************************************/
bool Protein::SaveChains(string dirname,string filename)
{
	
	string line,fname,tempstr;
	Atom atom;
	int j,po;
	int num_atom;
	int chain_num;
	if(num_chain<1)
		return false;

	for(chain_num=0;chain_num<num_chain;chain_num++)
	{
		//Éú³ÉÎÄ¼þÃû
		if(filename!="AUTO")
		{
			fname=filename;
			if(chain_num>1)
			{
				if(m_chains[chain_num].chain_identifier!=' ')
				{
					po=(int)fname.find('.');
					tempstr=m_chains[chain_num].chain_identifier;
					fname.insert(po,tempstr);
				}
				else
				{
					po=(int)fname.find('.');					
					fname.insert(po,"A");
				}
			}
		}
		else
		{
			fname=PDB_id;
			if(num_chain>1)
			{
				if(m_chains[chain_num].chain_identifier!=' ')
				{					
					fname+=m_chains[chain_num].chain_identifier;
				}
				else
					fname+='A';
			}
			fname+=".ent";
		}
		//Ìí¼ÓÄ¿Â¼±êÊ¶
		if(dirname!="AUTO")
		{
			_mkdir(dirname.c_str());
			fname=dirname+"\\"+fname;
		}
		ofstream file;		
		file.open(fname.c_str(),ios::out);
		if(!file.is_open())
			return false;
		/*line="HEADER";
		line.resize(80);
		for(i=0;i<(int)PDB_id.length();i++)
			line[62+i]=PDB_id[i];
		file<<line<<endl;*/
		
		OutputPreField(file);		
		num_atom=m_chains[chain_num].num_atom;
		for(j=0;j<num_atom;j++)
		{
			atom=m_chains[chain_num].m_atoms[j];
			Atom2Line(atom,line);
			file<<line<<endl;
		}
		Atom2Ter(atom,line);
		file<<line<<endl;
		OutputSucField(file);
	}
	return true;
}
/**********************************************
 * Í³¼Æ°±»ùËá¶Ô¹Ç¼ÜÅ¤×ª½ÇµÄÇãÏòÐÔ
 * ¹Ç¼ÜÅ¤×ª½Ç±ØÐëÒÔ¼ÆËã
 * ÕâÀï¹Ç¼ÜÅ¤×ª½Ç·Ö³É36*36·Ý
 * ³É¹¦Ê±·µ»Øtrue£¬·ñÔò·µ»Øfalse
 *********************************************/
bool Chain::Pre_Dihedral(vector<vector<double> >& preference)
{
	int len,i,bin,bpsi,bphi,aa;
	double phi,psi;
	len=(int)m_residues.size();
	for(i=0;i<len;i++)
	{
		//¼ÆËã¹Ç¼ÜÅ¤×ª½ÇÀàÐÍ
		phi=m_residues[i].phi;
		psi=m_residues[i].psi;
		if(fabs(phi+999)<1e-5)//Á½Ãæ½Ç²»´æÔÚÔò²»Í³¼Æ
			continue;
		if(fabs(psi+999)<1e-5)
			continue;
		bphi=(int)((phi+180)/10);
		if(bphi>=36)
			bphi=36;
		bpsi=(int)((psi+180)/10);
		if(bpsi>=36)
			bpsi=36;
		bin=bphi*36+bpsi;
		if(bin>1295)
			return false;
		//¼ÆËã°±»ùËáÐòºÅ
		aa=Rname2ID(m_residues[i].c_name);		
		preference[bin][aa]+=1.0;
	}
	return true;
}
//¼ÆËãÃ¿¸ö°±»ùËáµÄ½Ó´¥¸öÊý
bool Chain::Cal_Num_Contact()
{
	int i,j,len;
	int index,atom_index;
	Point pi,pj;
	double distance;
	len=num_residue;

	for(i=0;i<len;i++)
	{
		index=Atomname2ID("CA");
		atom_index=m_residues[i].atom_index[index];
		if(atom_index==-1)
		{
			cout<<"¼ÆËã½Ó´¥¸öÊýÊ±³ö´í£ºÔÚ°±»ùËá"<<i+1<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
			return false;
		}
		pi=m_atoms[atom_index].pt;
		for(j=i+1;j<len;j++)
		{
			index=Atomname2ID("CA");
			atom_index=m_residues[j].atom_index[index];
			if(atom_index==-1)
			{
				cout<<"¼ÆËã½Ó´¥¸öÊýÊ±³ö´í£ºÔÚ°±»ùËá"<<j+1<<"ÖÐÕÒ²»µ½CAÔ­×Ó"<<endl;
				return false;
			}
			pj=m_atoms[atom_index].pt;
			distance=Distance(pi,pj);
			if(distance<=8)//¾àÀëÐ¡ÓÚ8°££¬¶¨ÒåÎª´æÔÚcontact
			{
				m_residues[i].num_contact++;
				m_residues[j].num_contact++;
			}
		}
	}
	return true;
}
//Í³¼Æ°±»ùËá¶Ô½Ó´¥¸öÊýÀàÐÍµÄ³öÏÖ´ÎÊý£¬½Ó´¥¸öÊý±ØÐëÒÑ¾­¼ÆËã
bool Chain::Pre_Num_Contact(vector<vector<double> >& preference)
{
	int i,len;
	int bin,aa;
	len=num_residue;

	for(i=0;i<len;i++)
	{
		bin=m_residues[i].num_contact;
		if(bin<1)
			bin=1;
		else if(bin>25)
			bin=25;
		bin-=1;//×ª±ä³ÉÐòºÅ
		aa=Rname2ID(m_residues[i].c_name);	
		preference[bin][aa]+=1.0;
	}
	return true;
}
bool IsDigit(string str)
{
	int i,len;
	len=(int)str.size();
	for(i=0;i<len;i++)
	{
		if((!isdigit(str[i]))&&(str[i]!=' ')&&(str[i]!='-'))
			return false;
	}
	return true;
}
/*********************************************************************
 * ÀÛ¼ÓÔ­×ÓÀàÐÍ1µÄÊÆÄÜ
 * Ô­×ÓÀàÐÍ1µÄÊÆÄÜÖ¸£ºÔ­×ÓÔÚÐòÁÐÉÏµÄ¼ä¸ô¾àÀëk·ÖÈýÖÐ£¬ÒÔ11ºÍ22Îª·Ö½çµã
 * Ô­×ÓÔÚ¿Õ¼äµÄ¾àÀëÀà±ð´Ó0±ä»¯µ½10£¬ÒÔ0.5Îª¼ä¸ô£¬20¸ö
 * ½ö¿¼ÂÇÖ÷Á´ÉÏµÄÖØÔ­×Ó¶Ô25¶Ô
 * ¶ÔÓ¦µÄÊÆÄÜÏòÁ¿µÄ³¤¶ÈÎª1500
 *********************************************************************/
bool Chain::Pre_Num_Atomtype1(vector<double>& preference)
{
	int i1,i2,len;
	int k,s,daa,po,kk,type1,type2;
	Point p1,p2;
	double distance;
	string atomname1,atomname2;

	len=this->num_atom;
	for(i1=0;i1<len;i1++)
	{
		atomname1=m_atoms[i1].name;
		if((atomname1=="CB")||(atomname1=="N")||(atomname1=="O")||(atomname1=="CA")||(atomname1=="C"))//Ô­×ÓÃû³ÆÔÚ¶ÁÈëÊ±ÒÑ¾­×ª»»Îª´óÐ´
		{
			p1=m_atoms[i1].pt;
			for(i2=i1+1;i2<len;i2++)
			{
				atomname2=m_atoms[i2].name;
				if((atomname2=="CB")||(atomname2=="N")||(atomname2=="O")||(atomname2=="CA")||(atomname2=="C"))
				{
					p2=m_atoms[i2].pt;
					distance=Distance(p1,p2);
					if(distance>=10.0)//³¬¹ý¸Ã¾àÀëµÄÔ­×Ó¶ÔºöÂÔµô
						continue;
					//È·¶¨¿Õ¼ä¾àÀë±àºÅs
					s=int(distance*2);
					if(s>=20)
						s=19;
					//È·¶¨°±»ùËá¼ä¸ô±àºÅk
					kk=m_atoms[i1].residule_chain_seqm-m_atoms[i2].residule_chain_seqm;
					if(kk<0)
						kk=-kk;
					if(kk<11)
						k=0;
					else if(kk>=11||kk<=22)
						k=1;
					else
						k=2;
					//È·¶¨Ô­×Ó¶Ô±àºÅ
					if(atomname1=="CA")
						type1=0;
					else if(atomname1=="CB")
						type1=1;
					else if(atomname1=="N")
						type1=2;
					else if(atomname1=="C")
						type1=3;
					else //"O"
						type1=4;
					if(atomname2=="CA")
						type2=0;
					else if(atomname2=="CB")
						type2=1;
					else if(atomname2=="N")
						type2=2;
					else if(atomname2=="C")
						type2=3;
					else //"O"
						type2=4;
					daa=type1*5+type2;
					po=k*500+s*25+daa;
					preference[po]+=1.0;
				}
			}
		}
	}
	return true;
}
/*********************************************************************
 * ÀÛ¼ÓÔ­×ÓÀàÐÍ2µÄÊÆÄÜ
 * Ô­×ÓÀàÐÍ1µÄÊÆÄÜÖ¸£ºÔ­×ÓÔÚÐòÁÐÉÏµÄ¼ä¸ô¾àÀëk·ÖÈýÖÐ£¬ÒÔ11ºÍ22Îª·Ö½çµã
 * Ô­×ÓÔÚ¿Õ¼äµÄ¾àÀëÀà±ð´Ó1.5±ä»¯µ½11.5£¬ÒÔ1Îª¼ä¸ô£¬10¸ö
 * Ô­×ÓÀàÐÍ¹²40¸ö,Ô­×Ó¶Ô1600¶Ô
 * ¶ÔÓ¦µÄÊÆÄÜÏòÁ¿µÄ³¤¶ÈÎª48000
 *********************************************************************/
bool Chain::Pre_Num_Atomtype2(vector<double>& preference)
{
	int i1,i2,len;
	int k,s,daa,po,kk,type1,type2;
	Point p1,p2;
	double distance;
	string atomname1,atomname2;	
	char c1,c2;
	int aaindex,atomindex;

	len=this->num_atom;
	for(i1=0;i1<len;i1++)
	{
		atomname1=m_atoms[i1].name;
		c1=m_atoms[i1].c_resname;
		aaindex=Rname2ID20(c1);//½«Ô­×ÓËùÔÚµÄ°±»ùËáÃû³Æ×ª»»³É20¸ö±ê×¼°±»ùËáÐòºÅ
		if(aaindex==-1)
		{
			cout<<"¾¯¸æ:³öÏÖÁËÎÞÐ§µÄ°±»ùËáÐòºÅµÚ"<<i1<<"¸öÔ­×ÓËùÔÚµÄ°±»ùËáÃû³ÆÎª"<<c1<<endl;
			cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
			continue;
		}
		atomindex=Atomname2ID(atomname1.c_str());//Ô­×ÓÃû³Æ×ª»»³ÉÐòºÅ
		if(atomindex==36)//ºöÂÔOXTÔ­×Ó
			continue;
		if(atomindex==-1)
		{
			cout<<"¾¯¸æ:³öÏÖÁËÎÞÐ§µÄÔ­×ÓÐòºÅµÚ"<<i1<<"¸öÔ­×ÓËùÃû³ÆÎª"<<atomname1.c_str()<<endl;
			cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
			continue;
		}
		type1=Atomtype40[aaindex][atomindex];
		if(type1==-1)
		{
			cout<<"¾¯¸æ:Î´ÄÜ»ñµÃÔ­×ÓµÄÕýÈ·ÐòºÅ°±»ùËáÃû³Æ"<<c1<<" ÐòºÅ"<<aaindex<<" Ô­×ÓÃû³Æ"<<atomname1.c_str()<<" ÐòºÅ"<<atomindex<<endl;
			cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
			continue;
		}
		//if((atomname1=="CB")||(atomname1=="N")||(atomname1=="O")||(atomname1=="CA")||(atomname1=="C"))//Ô­×ÓÃû³ÆÔÚ¶ÁÈëÊ±ÒÑ¾­×ª»»Îª´óÐ´
		{
			p1=m_atoms[i1].pt;
			for(i2=i1+1;i2<len;i2++)
			{
				atomname2=m_atoms[i2].name;
				c2=m_atoms[i2].c_resname;
				aaindex=Rname2ID20(c2);//½«Ô­×ÓËùÔÚµÄ°±»ùËáÃû³Æ×ª»»³É20¸ö±ê×¼°±»ùËáÐòºÅ
				if(aaindex==-1)
				{
					cout<<"¾¯¸æ:³öÏÖÁËÎÞÐ§µÄ°±»ùËáÐòºÅµÚ"<<i2<<"¸öÔ­×ÓËùÔÚµÄ°±»ùËáÃû³ÆÎª"<<c2<<endl;
					cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
					continue;
				}
				atomindex=Atomname2ID(atomname2.c_str());//Ô­×ÓÃû³Æ×ª»»³ÉÐòºÅ
				if(atomindex==36)//ºöÂÔOXTÔ­×Ó
					continue;
				if(atomindex==-1)
				{
					cout<<"¾¯¸æ:³öÏÖÁËÎÞÐ§µÄÔ­×ÓÐòºÅµÚ"<<i2<<"¸öÔ­×ÓËùÃû³ÆÎª"<<atomname2.c_str()<<endl;
					cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
					continue;
				}
				type2=Atomtype40[aaindex][atomindex];
				if(type2==-1)
				{
					cout<<"¾¯¸æ:Î´ÄÜ»ñµÃÔ­×ÓµÄÕýÈ·ÐòºÅ°±»ùËáÃû³Æ"<<c2<<" ÐòºÅ"<<aaindex<<" Ô­×ÓÃû³Æ"<<atomname2.c_str()<<" ÐòºÅ"<<atomindex<<endl;
					cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
					continue;
				}
				//if((atomname2=="CB")||(atomname2=="N")||(atomname2=="O")||(atomname2=="CA")||(atomname2=="C"))
				{
					p2=m_atoms[i2].pt;
					distance=Distance(p1,p2);
					if((distance<1.5)||(distance>=11.5))//³¬¹ý¸Ã¾àÀëµÄÔ­×Ó¶ÔºöÂÔµô
						continue;
					//È·¶¨¿Õ¼ä¾àÀë±àºÅs
					s=(int)(distance-1.5);
					if(s>=10)
						s=9;
					//È·¶¨°±»ùËá¼ä¸ô±àºÅk
					kk=m_atoms[i1].residule_chain_seqm-m_atoms[i2].residule_chain_seqm;					
					if(kk<0)
						kk=-kk;
					if(kk<=1) //ÏàÁÚ»òÕßÍ¬Ò»¸ö°±»ùËáÖ®ÄÚµÄ²»¼ÆËã
						continue;
					if(kk<11)
						k=0;
					else if(kk>=11||kk<=22)
						k=1;
					else
						k=2;					
					daa=(type1-1)*40+(type2-1);
					po=k*16000+s*1600+daa;
					preference[po]+=1.0;
				}
			}
		}
	}
	return true;
}
bool Chain::Pre_FS(vector<vector<vector< double> > >& preference)
{
	int i1,i2,len;
	int s,type1,type2;
	Point p1,p2;
	double distance,r1,r2;
	string atomname1,atomname2;	
	char c1,c2;
	int aaindex,atomindex;
	int residule_chain_seqm1,residule_chain_seqm2;

	len=this->num_atom;
	for(i1=0;i1<len;i1++)
	{
		atomname1=m_atoms[i1].name;
		c1=m_atoms[i1].c_resname;
		aaindex=Rname2ID20(c1);//½«Ô­×ÓËùÔÚµÄ°±»ùËáÃû³Æ×ª»»³É20¸ö±ê×¼°±»ùËáÐòºÅ
		if(aaindex==-1)
		{
			cout<<"¾¯¸æ:³öÏÖÁËÎÞÐ§µÄ°±»ùËáÐòºÅµÚ"<<i1<<"¸öÔ­×ÓËùÔÚµÄ°±»ùËáÃû³ÆÎª"<<c1<<endl;
			cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
			continue;
		}
		atomindex=Atomname2ID(atomname1.c_str());//Ô­×ÓÃû³Æ×ª»»³ÉÐòºÅ	
		if(atomindex==36)
			continue;
		if(atomindex==-1)
		{
			//cout<<"¾¯¸æ:³öÏÖÁËÎÞÐ§µÄÔ­×ÓÐòºÅµÚ"<<i1<<"¸öÔ­×ÓËùÃû³ÆÎª"<<atomname1.c_str()<<endl;
			//cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
			continue;
		}
		type1=Atomtype_FS[aaindex][atomindex];
		
		if(type1==-1)
		{
			cout<<"¾¯¸æ:Î´ÄÜ»ñµÃÔ­×ÓµÄÕýÈ·ÐòºÅ°±»ùËáÃû³Æ"<<c1<<" ÐòºÅ"<<aaindex<<" Ô­×ÓÃû³Æ"<<atomname1.c_str()<<" ÐòºÅ"<<atomindex<<endl;
			cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
			continue;
		}
		residule_chain_seqm1=m_atoms[i1].residule_chain_seqm;
		if(atomindex<17)//atom C
			r1=1.4;
		else if(atomindex<26)//atom N
			r1=1.2;
		else if(atomindex<37)//atom O
			r1=1.1;
		else //atom S
			r1=1.4;
		//if((atomname1=="CB")||(atomname1=="N")||(atomname1=="O")||(atomname1=="CA")||(atomname1=="C"))//Ô­×ÓÃû³ÆÔÚ¶ÁÈëÊ±ÒÑ¾­×ª»»Îª´óÐ´
		{
			p1=m_atoms[i1].pt;
			for(i2=i1+1;i2<len;i2++)
			{
				atomname2=m_atoms[i2].name;
				c2=m_atoms[i2].c_resname;
				aaindex=Rname2ID20(c2);//½«Ô­×ÓËùÔÚµÄ°±»ùËáÃû³Æ×ª»»³É20¸ö±ê×¼°±»ùËáÐòºÅ
				if(aaindex==-1)
				{
					cout<<"¾¯¸æ:³öÏÖÁËÎÞÐ§µÄ°±»ùËáÐòºÅµÚ"<<i2<<"¸öÔ­×ÓËùÔÚµÄ°±»ùËáÃû³ÆÎª"<<c2<<endl;
					cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
					continue;
				}
				atomindex=Atomname2ID(atomname2.c_str());//Ô­×ÓÃû³Æ×ª»»³ÉÐòºÅ
				if(atomindex==36)
					continue;
				if(atomindex==-1)
				{
					//cout<<"¾¯¸æ:³öÏÖÁËÎÞÐ§µÄÔ­×ÓÐòºÅµÚ"<<i2<<"¸öÔ­×ÓËùÃû³ÆÎª"<<atomname2.c_str()<<endl;
					//cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
					continue;
				}
				type2=Atomtype_FS[aaindex][atomindex];				
				if(type2==-1)
				{
					cout<<"¾¯¸æ:Î´ÄÜ»ñµÃÔ­×ÓµÄÕýÈ·ÐòºÅ°±»ùËáÃû³Æ"<<c2<<" ÐòºÅ"<<aaindex<<" Ô­×ÓÃû³Æ"<<atomname2.c_str()<<" ÐòºÅ"<<atomindex<<endl;
					cout<<"¸ÃÔ­×Ó½«±»ºöÂÔ"<<endl;
					continue;
				}
				residule_chain_seqm2=m_atoms[i2].residule_chain_seqm;
				if(atomindex<17)//atom C
					r2=1.4;
				else if(atomindex<26)//atom N
					r2=1.2;
				else if(atomindex<37)//atom O
					r2=1.1;
				else //atom S
					r2=1.4;
                //if((atomname2=="CB")||(atomname2=="N")||(atomname2=="O")||(atomname2=="CA")||(atomname2=="C"))
				{
					if((int)fabs((double)residule_chain_seqm1-residule_chain_seqm2)<4)//Ô­×ÓÔÚÐòÁÐÉÏµÄ¼ä¸ô
						continue;
					p2=m_atoms[i2].pt;
					distance=Distance(p1,p2);
					distance-=(r1+r2);
					if((distance<0)||(distance>=4))//³¬¹ý¸Ã¾àÀëµÄÔ­×Ó¶ÔºöÂÔµô
						continue;
					//È·¶¨¿Õ¼ä¾àÀë±àºÅs
					s=int(distance/0.2);
					if(s>19)
						s=19;					
					preference[type1][type2][s]+=1.0;
					preference[type2][type1][s]+=1.0;
				}
			}
		}
	}
	return true;
}
bool Protein::CalSAA()
{
    long i,j,k,index;
    double f,fatom;
    long FORLIM;
    Residue *WITH;
    long FORLIM1,FORLIM2;
	double boxmin[3],boxmax[3],v4[4];
    CAS *cas= CASCreate(2);


    AddToAllAtomRadii(RWATER); /* add the water radius :-) */ //to be added
    CalcResidueCenters();//to be added
    FORLIM = num_chain;
    for (i = 0; i < FORLIM; i++) 
	{
		FORLIM1=m_chains[i].num_residue;
		for(j=0;j<FORLIM1;j++)
		{	
			WITH = &m_chains[i].m_residues[j];
			boxmax[0]=WITH->boxmax.x; boxmax[1]=WITH->boxmax.y; boxmax[2]=WITH->boxmax.z;
			boxmin[0]=WITH->boxmin.x; boxmin[1]=WITH->boxmin.y; boxmin[2]=WITH->boxmin.z;
			FindNeighbourRes(boxmin, boxmax);
			f=0;
			FORLIM2=(int)WITH->m_atoms.size();
			for(k=0;k<FORLIM2;k++)
			{
				index=WITH->m_atoms[k];
				Atom2Pointer4(m_chains[i].m_atoms[index],v4);
				fatom=Surface(cas,v4);
				m_chains[i].m_atoms[index].saa=fatom;
				f+=fatom;
			}
			WITH->saa = (long)floor(f + 0.5);
	    }
	    
	}    
    AddToAllAtomRadii(-RWATER);   /* remove the water :-) */
    CASDelete(cas);
	return true;
}
/************************************
 * ËùÓÐÁ´µÄËùÓÐÔ­×Ó°ë¾¶Ôö¼Ór
 * rÎª¸ºÖµÊ±¼õÐ¡
 ***********************************/
void Protein::AddToAllAtomRadii(double r)
{
  long i, j, FORLIM;  
  long FORLIM1;

  FORLIM = num_chain;
  for (i = 0; i < FORLIM; i++) 
  {
	  FORLIM1=(int)m_chains[i].m_atoms.size();
	  for(j=0;j<FORLIM1;j++)
	  {
		  m_chains[i].m_atoms[j].radium+=r;		  
	  }
  }    
}  /* AddToAllAtomRadii */
void Protein::CalcResidueCenters()
{
  long i, j, k,index,FORLIM;
  long FORLIM1,FORLIM2;
  double boxmin[3],boxmax[3],v4[4];
  Residue * re;

  FORLIM = num_chain;
  for(i=0;i<FORLIM;i++)
  {
	  FORLIM1=m_chains[i].num_residue;
	  for(j=0;j<FORLIM1;j++)
	  {
		  boxmax[0] = -1e10;
		  boxmax[1] = -1e10;
		  boxmax[2] = -1e10;
		  boxmin[0] = 1e10;
		  boxmin[1] = 1e10;
		  boxmin[2] = 1e10;
		  FORLIM2=(int)m_chains[i].m_residues[j].m_atoms.size();
		  re=&m_chains[i].m_residues[j];
		  for(k=0;k<FORLIM2;k++)
		  {
			  index=re->m_atoms[k];
			  Atom2Pointer4(m_chains[i].m_atoms[index],v4);
			  MinMax(v4,boxmin,boxmax);
		  }
		  re->boxmax.x=boxmax[0];re->boxmax.y=boxmax[1];re->boxmax.z=boxmax[2];
		  re->boxmin.x=boxmin[0];re->boxmin.y=boxmin[1];re->boxmin.z=boxmin[2];		  
	  }
  }  
}  /* CalcResidueCenters */
void Protein::FindNeighbourRes(double *vmin, double *vmax)//PDB
{
  long i,j,FORLIM,FORLIM1;

  LastNeighbourRes = 0;
  FORLIM = num_chain;
  /* gcc (2.5.7 and 2.4.5) have problems on some machines with */
  /* -funroll-loops here.*/
  /* e.g on SGI 1tim produces wrong results!!!! */
  for (i = 0; i < FORLIM; i++) 
  {
	  FORLIM1=m_chains[i].num_residue;
	  for(j=0;j<FORLIM1;j++)
	  {
		if(
		vmin[0] < m_chains[i].m_residues[j].boxmax.x && vmin[1] < m_chains[i].m_residues[j].boxmax.y &&
		vmin[2] < m_chains[i].m_residues[j].boxmax.z && vmax[0] > m_chains[i].m_residues[j].boxmin.x &&
		vmax[1] > m_chains[i].m_residues[j].boxmin.y && vmax[2] > m_chains[i].m_residues[j].boxmin.z) 
		{
			LastNeighbourRes++;	  
			NeighbourRes[LastNeighbourRes].chain = i;
			NeighbourRes[LastNeighbourRes].res  = j;
		}
	  }
  }
}  /*  FindNeighbourRes*/
  void Protein::Liste(CAS* cas, double *atom)//PDB
{
    long i, j,FORLIM;
    Residue *WITH;
    long FORLIM1;
	double boxmin[3],boxmax[3],v4[4];

    FORLIM = LastNeighbourRes;
    for (i = 1; i <= FORLIM; i++) 
	{
		WITH = &m_chains[NeighbourRes[i].chain].m_residues[NeighbourRes[i].res];
		boxmax[0]=WITH->boxmax.x;boxmax[1]=WITH->boxmax.y;boxmax[2]=WITH->boxmax.z;
		boxmin[0]=WITH->boxmin.x;boxmin[1]=WITH->boxmin.y;boxmin[2]=WITH->boxmin.z;
		if (InBox(atom, boxmin, boxmax)) 
		{
			FORLIM1=(int)WITH->m_atoms.size();
			for(j=0;j<FORLIM1;j++)
			{
				Atom2Pointer4(m_chains[NeighbourRes[i].chain].m_atoms[WITH->m_atoms[j]],v4);
				Listentry(cas, atom, v4);
			}			
		}
	}    
}  /* Liste */
double Protein::Surface(CAS* cas,double *xatom)
{
    double f;
    CASResetAtoms(cas);
    CASSetCenterAtom(cas,xatom[0],xatom[1],xatom[2],xatom[3]);
    Liste(cas, xatom);
    f= CASSurface(cas);
    return f;
}  /* Surface */
bool Chain::ComputSidecenter_Te13()
{
	int i,j,indexaa,num_sideatom;
	int atomindex;
	for(i=0;i<num_residue;i++)
	{
		m_residues[i].sidecenter_te13.x=0;
		m_residues[i].sidecenter_te13.y=0;
		m_residues[i].sidecenter_te13.z=0;
		num_sideatom=0;
		indexaa=Rname2ID20(m_residues[i].c_name);
		if(indexaa==-1)
			return false;
		for(j=0;j<NUM_ATOM_TYPE;j++)
		{
			if(SideAtom[indexaa][j])
			{
				atomindex=m_residues[i].atom_index[j];
				if(atomindex!=-1)
				{
					m_residues[i].sidecenter_te13=Add(m_residues[i].sidecenter_te13,m_atoms[atomindex].pt);
					num_sideatom++;
				}
			}
		}		
		if(indexaa==5)//GLY°±»ùËáÓÃCaÔ­×Ó´úÌæ
		{
			m_residues[i].sidecenter_te13=m_atoms[m_residues[i].atom_index[1]].pt;
		}
		else
		{
			if(num_sideatom==0)
				return false;
			m_residues[i].sidecenter_te13.x/=num_sideatom;
			m_residues[i].sidecenter_te13.y/=num_sideatom;
			m_residues[i].sidecenter_te13.z/=num_sideatom;
		}
	}
	return true;
}
bool Chain::ComputSidecenter_HRSC()
{
	int i,j,indexaa,num_sideatom;
	int atomindex;
	for(i=0;i<num_residue;i++)
	{
		m_residues[i].sidecenter_HRSC.x=0;
		m_residues[i].sidecenter_HRSC.y=0;
		m_residues[i].sidecenter_HRSC.z=0;
		num_sideatom=0;
		indexaa=Rname2ID20(m_residues[i].c_name);
		if(indexaa==-1)
			return false;
		for(j=0;j<NUM_ATOM_TYPE;j++)
		{
			if(SideAtom_HRSC[indexaa][j])
			{
				atomindex=m_residues[i].atom_index[j];
				if(atomindex!=-1)
				{
					m_residues[i].sidecenter_HRSC=Add(m_residues[i].sidecenter_HRSC,m_atoms[atomindex].pt);
					num_sideatom++;
				}
			}
		}
		if(num_sideatom==0)
		return false;
		m_residues[i].sidecenter_HRSC.x/=num_sideatom;
		m_residues[i].sidecenter_HRSC.y/=num_sideatom;
		m_residues[i].sidecenter_HRSC.z/=num_sideatom;		
	}
	return true;		
}
bool Chain::Pre_DFIRESCM(vector<vector<vector<double > > >& preference)
{
	char aa1,aa2;
	int i,j,aaindex1,aaindex2,disindex;
	double distance;
	Point p1,p2;
	
	int len=this->num_residue;	
	for(i=0;i<len;i++)
	{
		aa1=m_residues[i].c_name;
		aaindex1=Rname2ID20(aa1);
		if(aaindex1==-1)
			return false;
		p1=m_residues[i].sidecenter_te13;
		for(j=i+1;j<len;j++)
		{
			aa2=m_residues[j].c_name;
			aaindex2=Rname2ID20(aa2);
			if(aaindex2==-1)
				return false;
			p2=m_residues[j].sidecenter_te13;
			distance=Distance(p1,p2);
			if((distance>=0)&&(distance<=20))
			{
				disindex=Dis2DFIRESCMndex(distance);
				preference[aaindex1][aaindex2][disindex]+=1.0;
			}
		}
	}		
	return true;
}
int Dis2DFIRESCMndex(double dis)
{
	int i,index;
	double center[20]={1,2.25,2.75,3.25,3.75,4.25,4.75,5.25,5.75,6.25,6.75,7.25,7.75,8.5,9.5,10.5,11.5,12.5,13.5,14.5};
	double radius[20]={1,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.5,0.5,0.5,0.5,0.5,0.5,0.5};
	index=0;
	for(i=0;i<20;i++)
	{
		if((dis>=(center[i]-radius[i]))&&(dis<=(center[i]+radius[i])))
			{
				index=i;
				break;
			}
	}
	if(index<0)
		index=0;
	if(index>=20)
		index=19;
	return index;
}
